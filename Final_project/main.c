#pragma config(Sensor, dgtl2,  elbow_down,     sensorTouch)
#pragma config(Sensor, dgtl4,  LimitSwitchshoulder, sensorTouch)
#pragma config(Sensor, dgtl5,  elbow_up,       sensorTouch)
#pragma config(Sensor, dgtl6,  elbowEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl11, ShoulderEncoder, sensorQuadEncoder)
#pragma config(Motor,  port3,           elbow,         tmotorVex393, openLoop)
#pragma config(Motor,  port4,           shoulder,      tmotorVex393, openLoop)
#pragma config(Motor,  port5,  Servo,               tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int c = 0;

// open the claw to the max
void open_claw(){
	motor[Servo] = 127;
}

// hold the claw after pick up the can
void hold_claw(){
	motor[Servo] = -127;
}

// calculate the angle for baase_sholder 
int eval_A(int a, int b,int c){
	float x = acos((float)(b * b + c * c - a*a)/(2*b*c));
	return (int)((x * 180)/3.1415);
}

// calculate the angle for shoulder_elbow
int eval_C(int a, int b,int c){
	float x = acos((float)(a * a + b * b - c*c)/(2*b*a));
	return (int)((x * 180)/3.1415);
}

// whenever finish picking up the can , move the eblow and shoulder to its init position
void reset(){
	// move elbow to its init posn
	while(! SensorValue(elbow_up)){
				motor[elbow] = -30;
				//writeDebugStream("elbowEncoder : %d;\n",SensorValue[elbowEncoder]);
	}
	motor[elbow] = 0;
	// move the shoulder to the init position
	while(! SensorValue(LimitSwitchshoulder)){
				motor[shoulder] = 30;
	}
	// stop moving 
	motor[shoulder] = 0;
	// open
	open_claw();

	// reset the encoder value 
	SensorValue[ShoulderEncoder] = 0;
	SensorValue[elbowEncoder] = 0;
}

// move shoulder base on the given angle 
void move_shoulder(int ang){
	while(SensorValue[ShoulderEncoder] < (ang * 20.1)){
		motor[shoulder] = -30;
	}
	motor[shoulder] = 0;
}

// move elbow bae on the given angle 
void move_elbow(int ang){
	while(SensorValue[elbowEncoder] < (ang * 3) && SensorValue[elbowEncoder] < 1000){
		motor[elbow] = 19;
		//writeDebugStream("elbowEncoder : %d;\n",SensorValue[elbowEncoder]);
	}
	motor[elbow] = 0;
}


task main(){
	// the max angle shoulder can reach
	int shoulder_limit = 75;
	// constant for eblow length
	int a = 30;
	// cosntant for shoulder length
	int b = 32;
	// go to init positoin 
	reset();
  while(1){
  	// if the can is to far, 
  	if(c > 800)
  		return;
		

  	// shoulder moving angle 
  	int A = eval_A(a,b,c);
 		wait1Msec(500);
  	// prevent shoulder from move exceed limit
  	if(A > shoulder_limit)
  			A = shoulder_limit;
  	// for the can closer, we need to move an a little bit higher
  	// for the can that can, we not going to move to much,
  	// the numbr 110 and 12.5 are the magic number generate by 100 try
		int magic_number = (int) (((float)(A)/110) * 12.5);
  	move_shoulder(A+magic_number);
		
  	// calculate the C angle
  	int C = eval_C(a,b,c);
  	// 120 move eblow to the parallel about elbow and shoulder
  	C = 120 + (180 - c);
  	// far the can is, less elbow move, kind make the vlaw pareel witht he can with this magic number
  	magic_number = (int)(((float)(c)/58)* 27);
  	wait1Msec(1000);
  	// if the angle is small, no need for the balance
  	move_elbow(C - ((magic_number <= 20) ? 0 : (int)(magic_number * 1.7));
  	wait1Msec(1000);
  	hold_claw();
  	wait1Msec(1000);
  	move_shoulder(80);
  	reset();

}

}
